// PolylineController 클래스의 _setOptions 메서드
PolylineController.prototype._setOptions = function(a) {
    // 주어진 옵션 객체(a)에서 값을 가져오거나, 기본값(Default)을 사용합니다.
    this._draggable = a.draggable || Default.draggable;
    this._removable = a.removable || Default.removable;
    this._editable = a.editable || Default.editable;
    this._zIndex = a.zIndex || Default.zIndex;
    this._strokeWeight = a.strokeWeight || Default.strokeWeight;
    this._strokeColor = a.strokeColor || Default.strokeColor;
    this._strokeOpacity = a.strokeOpacity || Default.strokeOpacity;
    this._strokeStyle = a.strokeStyle || Default.strokeStyle;
    this._fillColor = a.fillColor || Default.fillColor;
    this._fillOpacity = a.fillOpacity || Default.fillOpacity;
    this._hintStrokeOpacity = a.hintStrokeOpacity || 0.5 * Default.strokeOpacity;
    this._hintStrokeStyle = a.hintStrokeStyle || Default.strokeStyle;
    this._hintFillOpacity = a.hintFillOpacity || Default.fillOpacity;
};

// PolylineController 클래스의 _start 메서드
PolylineController.prototype._start = function(a) {
    var b = this._map, // 지도 객체
        c = this._startCoords = this._endCoords = GET_COORDS(a), // 클릭한 좌표
        d = this._startVertex, // 시작 점 Vertex 객체
        e = this._endVertex; // 끝 점 Vertex 객체

    // 시작 점과 끝 점의 좌표를 설정하고 지도에 추가합니다.
    d.setPosition(c);
    e.setPosition(c);
    d.setMap(b);
    e.setMap(b);

    // 폴리라인의 경로를 설정합니다.
    this._path = [c];

    // 폴리곤 옵션이 설정되어 있다면 폴리곤을 생성하고 지도에 추가합니다.
    if (this._closed) {
        this._hintArea = new daum.maps.Polygon({
            map: b,
            path: this._path,
            strokeOpacity: 0,
            fillColor: this._fillColor,
            fillOpacity: this._hintFillOpacity || this._fillOpacity
        });
    }

    // 실제 폴리라인과 힌트 폴리라인을 생성하고 지도에 추가합니다.
    this._track = new daum.maps.Polyline({
        map: b,
        path: this._path,
        strokeWeight: this._strokeWeight,
        strokeOpacity: this._strokeOpacity,
        strokeColor: this._strokeColor,
        strokeStyle: this._strokeStyle,
        startArrow: this._hasStartArrow
    });
    this._hint = new daum.maps.Polyline({
        map: b,
        path: [c],
        strokeWeight: this._strokeWeight,
        strokeColor: this._strokeColor,
        strokeOpacity: this._hintStrokeOpacity || this._strokeOpacity,
        strokeStyle: this._hintStrokeStyle || this._strokeStyle,
        endArrow: this._hasEndArrow
    });

    // 클릭 이벤트 리스너를 추가하여 폴리라인 그리기 작업을 처리합니다.
    daum.maps.event.removeListener(b, "click", this._startHandler);
    this._startHandler = null;
    this._drawHandler = this._draw.bind(this);
    this._drawHintHandler = this._drawHint.bind(this);
    daum.maps.event.addListener(b, "click", this._drawHandler);
    daum.maps.event.addListener(b, "mousemove", this._drawHintHandler);

    // "drawstart" 이벤트를 디스패치하여 폴리라인 그리기 시작을 알립니다.
    this._dispatchEvent("drawstart", {
        coords: c,
        point: a.point
    });
};



// PolylineController 클래스의 _drawHint 메서드
PolylineController.prototype._drawHint = function(a) {
    var b = GET_COORDS(a); // 클릭한 좌표
    // 폴리라인이 닫혀있고, 힌트 폴리곤이 설정되어 있다면 경로를 업데이트합니다.
    this._closed && this._hintArea.setPath(this._path.concat(b));
    // 힌트 폴리라인을 업데이트하고 "draw" 이벤트를 디스패치합니다.
    this._hint.setPath([this._endCoords, b]);
    this._dispatchEvent("draw", {
        coords: b,
        point: a.point
    });
};

// PolylineController 클래스의 _draw 메서드
PolylineController.prototype._draw = function(a) {
    daum.maps.event.preventMap(); // 기본 지도 클릭 이벤트를 막습니다.
    var b = GET_COORDS(a); // 클릭한 좌표
    // 경로에 클릭한 좌표를 추가하고 폴리라인을 업데이트합니다.
    this._path.push(b);
    this._track.setPath(this._path);
    this._endVertex.setPosition(b);
    this._endCoords = b;
    this._endPoint = a.point;
    // "drawnext" 이벤트를 디스패치합니다.
    this._dispatchEvent("drawnext", {
        coords: b,
        point: a.point
    });
};

// PolylineController 클래스의 _done 메서드
PolylineController.prototype._done = function(a) {
    daum.maps.event.preventMap(); // 기본 지도 클릭 이벤트를 막습니다.
    if (!this._isDone) {
        this._isDone = !0;
        setTimeout(function() {
            this._isDone = !1
        }.bind(this), 0);
        var b = this._startVertex,
            c = this._endVertex;
        // 시작점과 끝점이 동일한 경우 취소합니다.
        if (b.getPosition() == c.getPosition())
            this._cancel();
        else {
            // 시작점이라면, 폴리라인이 닫혀있지 않고, 폴리라인이 닫혀있다면 경로에 시작점을 추가합니다.
            "start" == a && !this._closed && this._path.push(this._path[0]);
            // 폴리라인과 관련된 객체들을 제거합니다.
            this._track.setMap(null);
            this._hint.setMap(null);
            this._hint = this._track = null;
            this._closed && (this._hintArea.setMap(null),
            this._hintArea = null);
            b.setMap(null);
            c.setMap(null);
            var d = this._map,
                e = new (this._closed ? ExtendsPolygon : ExtendsPolyline)({
                    map: d,
                    index: this._index,
                    path: this._path,
                    removable: this._removable,
                    draggable: this._draggable,
                    strokeWeight: this._strokeWeight,
                    strokeOpacity: this._strokeOpacity,
                    strokeColor: this._strokeColor,
                    strokeStyle: this._strokeStyle,
                    fillColor: this._fillColor,
                    fillOpacity: this._fillOpacity,
                    startArrow: this._hasStartArrow,
                    endArrow: this._hasEndArrow
                });
            // 폴리라인 관련 이벤트를 처리하고 폴리라인 객체를 추가합니다.
            e.onRemove.add(this._remove, this);
            e.setRemovable(this._removable);
            e.setDraggable(this._draggable);
            e.setEditable(this._editable);
            e.setHoverable(this._draggable || this._editable);
            this._figures.push(e);
            this._index++;
            // 이벤트 리스너를 제거합니다.
            daum.maps.event.removeListener(d, "click", this._drawHandler);
            daum.maps.event.removeListener(d, "mousemove", this._drawHintHandler);
            this._drawHintHandler = this._drawHandler = null;
            d = d.getProjection();
            a = "start" == a ? b.getPosition() : c.getPosition();
            b = d.pointFromCoords(a);
            // "drawend" 이벤트를 디스패치합니다.
            this._dispatchEvent("drawend", {
                coords: a,
                point: b,
                target: e
            });
            this.onCursorChange.notify(null);
        }
    }
};

// PolylineController 클래스의 _cancel 메서드
PolylineController.prototype._cancel = function() {
    var a = this._map;
    // 폴리라인 및 관련 객체들을 제거합니다.
    this._track && (this._track.setMap(null),
    this._hint.setMap(null),
    this._hint = this._track = null,
    this._closed && (this._hintArea.setMap(null),
    this._hintArea = null),
    this._startVertex.setMap(null),
    this._endVertex.setMap(null));
    this._startHandler && (daum.maps.event.removeListener(a, "click", this._startHandler),
    this._startHandler = null);
    this._drawHandler && (daum.maps.event.removeListener(a, "click", this._drawHandler),
    daum.maps.event.removeListener(a, "mousemove", this._drawHintHandler),
    this._drawHintHandler = this._drawHandler = null);
    // 커서를 초기화하고 "cancel" 이벤트를 디스패치합니다.
    this.onCursorChange.notify(null);
    this._dispatchEvent("cancel");
};

// PolylineController 클래스의 _remove 메서드
PolylineController.prototype._remove = function(a) {
    // 폴리라인 배열을 순회하면서 제거할 객체를 찾습니다.
    this._figures.forEach(function(b, c) {
        if (b == a || c == a) {
            // 해당 객체를 배열에서 제거하고 인덱스를 재설정합니다.
            this._figures.splice(c, 1);
            this._figures.forEach(function(a, b) {
                a.setIndex(b);
            });
            this._index--;
        }
    }, this);
    // "remove" 이벤트를 디스패치합니다.
    this._dispatchEvent("remove");
};

// PolylineController 클래스의 select 메서드
PolylineController.prototype.select = function() {
    // _select 메서드를 호출합니다.
    this._select();
};

// PolylineController 클래스의 cancel 메서드
PolylineController.prototype.cancel = function() {
    // _cancel 메서드를 호출합니다.
    this._cancel();
};

// PolylineController 클래스의 remove 메서드
PolylineController.prototype.remove = function(a) {
    // 폴리라인 배열을 순회하면서 제거할 객체를 찾아 제거합니다.
    this._figures.forEach(function(b, c) {
        (b == a || c == a) && b.remove();
    }, this);
};

// PolylineController 클래스의 setStyle 메서드
PolylineController.prototype.setStyle = function(a, b) {
    // 스타일 속성을 업데이트합니다.
    this["_" + a] = b;
};

// PolylineController 클래스의 get 메서드
PolylineController.prototype.get = function(a) {
    // 해당 속성의 값을 반환합니다.
    return this["_" + a];
};

// PolylineController 클래스의 getObjects 메서드
PolylineController.prototype.getObjects = function() {
    // 폴리라인 객체 배열을 반환합니다.
    return this._figures;
};

// PolylineController 클래스의 getData 메서드
PolylineController.prototype.getData = function() {
    // 데이터를 반환합니다.
    var a = this._hasEndArrow ? "arrow" : this._closed ? "polygon" : "polyline",
        b = [];
    this._figures.forEach(function(c) {
        var d = c.getPath().map(TO_XY),
            d = {
                type: a,
                points: d,
                coordinate: GET_COORD_SYSTEM(),
                options: {
                    strokeColor: c.getStrokeColor(),
                    strokeWeight: c.getStrokeWeight(),
                    strokeStyle: c.getStrokeStyle(),
                    strokeOpacity: c.getStrokeOpacity()
                }
            };
        // 폴리곤의 경우 추가 속성을 설정합니다.
        this._closed && (d.options.fillColor = c.getFillColor(),
        d.options.fillOpacity = c.getFillOpacity());
        // 화살표의 여부를 확인하고 추가 속성을 설정합니다.
        this._hasStartArrow && (d.options.startArrow = !0);
        this._hasEndArrow && (d.options.endArrow = !0);
        b.push(d);
    }, this);
    return b;
};


// PolylineController 클래스의 getState 메서드
PolylineController.prototype.getState = function() {
    // 현재 상태의 데이터를 가져옵니다.
    var a = this.getData();
    // 폴리라인 배열을 순회하면서 추가 정보를 합칩니다.
    this._figures.forEach(function(b, c) {
        drawing.merge(a[c], {
            order: b.getOrder(),
            removable: this._removable,
            draggable: this._draggable,
            editable: this._editable
        });
    }, this);
    // 최종 상태를 반환합니다.
    return a;
};

// PolylineController 클래스의 clear 메서드
PolylineController.prototype.clear = function(a) {
    // 그리기 작업을 취소합니다.
    this._cancel();
    // 폴리라인 배열을 역순으로 순회하면서 제거합니다.
    for (var b = this._figures.length - 1; 0 <= b; b--)
        a ? this._figures[b].removeWithoutNotify() : this._figures[b].remove();
    // 인덱스와 배열을 초기화합니다.
    this._index = 0;
    this._figures = [];
    this._figures.length = 0;
};

// PolylineController 클래스의 put 메서드
PolylineController.prototype.put = function(a, b) {
    // 새로운 폴리라인 객체를 생성합니다.
    var c = {
        map: this._map,
        index: this._index++,
        path: a,
        removable: this._removable,
        draggable: this._draggable,
        strokeWeight: this._strokeWeight,
        strokeOpacity: this._strokeOpacity,
        strokeColor: this._strokeColor,
        strokeStyle: this._strokeStyle,
        fillColor: this._fillColor,
        fillOpacity: this._fillOpacity,
        startArrow: this._hasStartArrow,
        endArrow: this._hasEndArrow
    };
    // 사용자 지정 속성을 병합합니다.
    drawing.merge(c, b);
    // 새로운 객체를 생성하고 이벤트를 등록합니다.
    c = new (this._closed ? ExtendsPolygon : ExtendsPolyline)(c);
    c.onRemove.add(this._remove, this);
    c.setRemovable(this._removable);
    c.setDraggable(this._draggable);
    c.setEditable(this._editable);
    c.setHoverable(this._draggable || this._editable);
    c.setVertexVisible(!1);
    // 배열에 추가하고 이벤트를 발생시킵니다.
    this._figures.push(c);
    this._dispatchEvent("put", {
        target: c
    });
};
